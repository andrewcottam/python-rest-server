#!/home/ubuntu/anaconda2/bin/python
#the above line forces the CGI script to use the Anaconda Python interpreter
import sys, os, web, subprocess, urllib, pandas, json, glob
import geopandas as gpd
MARXAN_FOLDER = "/home/ubuntu/workspace/marxan/Marxan243/MarxanData_unix"
MARXAN_EXECUTABLE = MARXAN_FOLDER + os.sep + "MarOpt_v243_Linux64"
MARXAN_OUTPUT_FOLDER = MARXAN_FOLDER + os.sep + "output" + os.sep
MARXAN_INPUT_PARAMETER_FILENAME = MARXAN_FOLDER + os.sep + "input.dat"

urls = (
  "/run", "runMarxan", # example call: https://db-server-blishten.c9users.io/marxan/webAPI/run
  "/loadSolution", "loadSolution" # example call: https://db-server-blishten.c9users.io/marxan/webAPI/loadSolution
  )
  
def getQueryStringParams(querystring):
    if len(querystring):
        return dict([(q.split("=")[0].upper(), urllib.unquote(q.split("=")[1])) for q in querystring.split("&")])
    else:
        return None

def injectRunParameters(newParams):
    if newParams:
        #get the existing parameters 
        paramsFile = open(MARXAN_INPUT_PARAMETER_FILENAME, 'rb')
        s = paramsFile.read()
        paramsFile.close()
        #update any that are passed in as query params
        for k, v in newParams.iteritems():
            try:
                p1 = s.index(k) #get the first position of the parameter
                if p1:
                    p2 = s[p1:].index("\r\n") #get the position of the end of line
                    s = s[:p1] + k + " " + v + s[(p1 + p2):]
                #write these parameters back to the input.dat file
                paramsFile = open(MARXAN_INPUT_PARAMETER_FILENAME, 'wb')
                paramsFile.write(s)
                paramsFile.close()
            except ValueError:
                continue
    return 

def createShapefileWithResults():
    #get the planning units as a GeoDataFrame
    planning_units = gpd.read_file(MARXAN_FOLDER + os.sep + "pulayer1km.shp")
    #get the summed solutions as a DataFrame
    summed_solution = pandas.read_csv(MARXAN_OUTPUT_FOLDER + "output_ssoln.txt")
    #join these datasets together 
    summed_solution_shapes = planning_units.merge(summed_solution,left_on="PUID",right_on="planning_unit")
    #write the results to a shapefile
    summed_solution_shapes.to_file(MARXAN_OUTPUT_FOLDER + "results.shp")

def deleteAllFiles(folder):
    files = glob.glob(folder + "*")
    for f in files:
        os.remove(f)

#runs marxan and returns the sum of solutions, summary info on all runs and the log
# optionally returns the data from all the individual runs (if the returnall=true parameter is set)
class runMarxan:
    def GET(self):
        try:
            #get the parameters to pass on to marxan
            params = getQueryStringParams(web.ctx.query[1:])
            #inject these into the input.dat file
            injectRunParameters(params)
            #set the current directory so files can be found in the input.dat file
            os.chdir(MARXAN_FOLDER) 
            #delete all of the current output files
            deleteAllFiles(MARXAN_OUTPUT_FOLDER)
            #run marxan using the passed parameters 
            p = subprocess.Popen([MARXAN_EXECUTABLE], stdout=subprocess.PIPE) 
            #get the results of the marxan run
            log, err = p.communicate()
            
            #create a shapefile with the results
            #createShapefileWithResults()
            
            #get the summary information
            sum = pandas.read_csv(MARXAN_OUTPUT_FOLDER + "output_sum.txt").to_json(orient='records') 
            
            #get the summed solution as a json string
            ssoln = pandas.read_csv(MARXAN_OUTPUT_FOLDER + "output_ssoln.txt").to_json(orient='records') 
            
            #iterate through each of the solutions and get the data
            solutionFiles = glob.glob(MARXAN_OUTPUT_FOLDER + "/output_r*")
            solutionDicts = {}
            # for solution in solutions if wanted
            if "RETURNALL" in params.keys():
                if (params["RETURNALL"]=='true'):
                    for f in solutionFiles:
                        solutionDicts.update({os.path.basename(f).split(".")[0] : json.loads(pandas.read_csv(f).to_json(orient='records'))})
            
            #add the other items
            solutionDicts['log'] = log
            solutionDicts['sum'] = json.loads(sum)
            solutionDicts['ssoln'] = json.loads(ssoln)
            
        except subprocess.CalledProcessError as e:
            return "Marxan return code: " + str(e.returncode)
        
        #web response
        web.header('Content-Type','application/json') 
        response = json.dumps(solutionDicts)
        #get the callback parameter for jsonp calls
        if "CALLBACK" in params.keys():
            return params["CALLBACK"] + "(" + response + ")"
        else:
            return response

#for loading each individual solution - pass the solution number as solution=1
class loadSolution:
    def GET(self):
        #get the parameters to pass on to marxan
        params = getQueryStringParams(web.ctx.query[1:])
        if not params:
            return "No solution number"
        else:
            #get the content from the solution - this will be 'output_r00001.txt'
            solution = pandas.read_csv(MARXAN_OUTPUT_FOLDER + "output_r" + "%05d" % (int(params["SOLUTION"]),)  + ".txt").to_json(orient='records') 
            response = json.dumps(json.loads(solution))
            web.header('Content-Type','application/json') 
            
            #get the callback parameter for jsonp calls
            if "CALLBACK" in params.keys():
                return params["CALLBACK"] + "(" + response + ")"
            else:
                return response
        
app = web.application(urls, locals()) 

if __name__ == "__main__":
    app.run()